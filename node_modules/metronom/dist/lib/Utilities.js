"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwError = exports.safeWrite = exports.safeRead = exports.hasJsonStructure = exports.getKeyValue = exports.isObject = void 0;
/* eslint-disable eqeqeq */
const Constants_1 = require("./Constants");
const Logger_1 = __importDefault(require("./Logger"));
/**
 * Utilities
 * @category Utilities
 */
function isObject(variable) {
    return variable === null || (variable && variable.toString() === '[object Object]');
}
exports.isObject = isObject;
/**
 * Get value's of object with key
 * @param key - wanted key of object
 * @example
 * ```
 *  getKeyValue("name")(user) // joey
 * ```
 */
const getKeyValue = (key) => (obj) => obj[key];
exports.getKeyValue = getKeyValue;
const hasJsonStructure = (str) => {
    if (typeof str !== 'string')
        return false;
    try {
        const result = JSON.parse(str);
        const type = Object.prototype.toString.call(result);
        return type === '[object Object]'
            || type === '[object Array]';
    }
    catch (err) {
        return false;
    }
};
exports.hasJsonStructure = hasJsonStructure;
/**
 * Read record from Redis and restruct it like schema
 * @param redisKey - Redis record key with `keyPrefix` and `keyUnique`
 * @param redisClient - Connected Redis client
 * @param schema - Model schema
 * @returns raw object
 */
const safeRead = async (redisKey, redisClient, schema) => {
    const response = await redisClient.hGetAll(redisKey);
    const entries = Object
        .entries(response)
        .map(([key, value]) => {
        if (value != undefined || value != null) {
            if ((0, exports.hasJsonStructure)(value)) {
                value = JSON.parse(value);
            }
            else {
                value = new schema[key].type(value).valueOf(); // convert to primative type
            }
        }
        return [key, value];
    });
    return Object.fromEntries(entries);
};
exports.safeRead = safeRead;
/**
 * Control data with isFlex and schema then serialize and write it into redis
 * @param data - Raw data
 * @param redisKey - Redis record key with `keyPrefix` and `keyUnique`
 * @param redisClient  - Connected Redis client
 * @param isFlex - if it is true you can pass diffirent key from schema
 * @param schema - Model schema
 */
const safeWrite = async (data, redisKey, redisClient, schema = {}, isFlex = false) => {
    if (!isFlex) { // if isFlex is falsy, you can only save fields inside the schema
        const temp = { ...data };
        data = {};
        Object.entries(schema).forEach(([key, value]) => {
            if (!Object.hasOwn(temp, key)) {
                data[key] = value.default;
            }
            else {
                // data: { a, b, c } | schema: { b, c, d } ==> temp: { b, c, d}
                data[key] = temp[key]
                    // @ts-ignore
                    || (value.type == Constants_1.Types.Array ? value.default : new value.type(value.default).valueOf());
            }
        });
    }
    const keysAndValues = Object
        .entries(data)
        .map(([key, value]) => [key, typeof value === 'object' ? JSON.stringify(value) : value]); // include array, objects etc.
    await redisClient.hSet(redisKey, keysAndValues);
    return data;
};
exports.safeWrite = safeWrite;
/**
 * Throw and log error with Metronom's internal Logger
 * @param message {string}
 */
const throwError = (message) => {
    Logger_1.default.error(message);
    throw new Error(message);
};
exports.throwError = throwError;

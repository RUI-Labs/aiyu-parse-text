"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Model_1 = __importDefault(require("./Model"));
const Utilities_1 = require("./Utilities");
const NodeRedisAdaptor_1 = __importDefault(require("./adaptors/NodeRedisAdaptor"));
const Logger_1 = __importDefault(require("./Logger"));
/**
 * Metronom model creator
 * @class Metronom
 * @category Metronom
 */
class Metronom {
    redisClientOptions;
    log;
    #redisClient;
    /**
     * Base Metronom object.
     * You can create new metronom instance with diffirent options like redis url.
     * @constructor
     * @param {MetronomOptions} options redis client settings
     * @returns {Metronom} new record of Metronom object
     */
    constructor(options) {
        this.redisClientOptions = options?.redisClientOptions;
        this.log = options?.log;
        this.#redisClient = null;
    }
    /**
     * Create metronom model from this Metronom object
     *
     * @param {Schema} schema - Record's key-value schema
     * @param {string} keyPrefix - Record unique key's prefix.
     * `"users:1234"` --> "`keyPrefix`:`keyUnique`"
     * @param {ModelOptions} modelOption - Optional model settings. It's include 3 key.
     *   + `keyUnique`: it's unique part of model key
     *   + `flexSchema`: Normally, you can't define any key except the fields in `schema`,
     *                   but if this value is `true`, you can only add a value to the schema
     * by giving it `keyUnique`
     *   + `redisClientOptions`: node-redis client options.
     * @returns {Model} new record of Model
     */
    define(schema, keyPrefix = 'object', modelOptions) {
        const redisOption = this.redisClientOptions
            ? this.redisClientOptions
            : modelOptions?.redisClientOptions;
        const log = this.log
            ? this.log
            : modelOptions?.log;
        return new Model_1.default(schema, keyPrefix, {
            ...modelOptions,
            log,
            redisClientOptions: redisOption,
        });
    }
    /**
     * Create String key or update if it exist.
     * Redis's "SET" command
     * @param {strin} key redis key
     * @param {string} value value
     * @returns it return "OK" if the process done
     */
    async setKey(key, value) {
        if (key === '') {
            (0, Utilities_1.throwError)('setKey: Keys can\'t be empty!');
        }
        this.#connectToRedis();
        // @ts-ignore
        return await this.#redisClient.set(key, value);
    }
    /**
     * Read String key
     * Redis's "GET" command
     * @param {string} key Redis key
     * @returns if the key is exist it return the value else return null
     */
    async getKey(key) {
        if (key === '' || key === undefined) {
            (0, Utilities_1.throwError)('getKey: Keys can\'t be empty!');
        }
        this.#connectToRedis();
        // @ts-ignore
        return this.#redisClient.get(key);
    }
    #connectToRedis() {
        if (this.#redisClient === null) {
            // @ts-ignore
            this.#redisClient = new NodeRedisAdaptor_1.default(this.redisClientOptions);
            this.#redisClient.connect();
            new Logger_1.default(this.log);
        }
    }
}
exports.default = Metronom;

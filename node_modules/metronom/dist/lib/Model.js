"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ModelInstance_1 = __importDefault(require("./ModelInstance"));
const NodeRedisAdaptor_1 = __importDefault(require("./adaptors/NodeRedisAdaptor"));
const Logger_1 = __importDefault(require("./Logger"));
const Utilities_1 = require("./Utilities");
/**
 * Model Class
 * @class Model
 * @category Model
 */
class Model {
    /** First part of redis key. It's identifier for model class */
    keyPrefix;
    /** Second part of redis key. It's identifier for record */
    keyUnique;
    /** Object struct model */
    schema;
    redisClient;
    /** you can't define any key except the fields in `schema`, but if this value is `true`,
     * you can only add a value to the schema by giving it `keyUnique`
     */
    flexSchema;
    /**
     * Represents a Metronom ORM Model
     * @constructor
     * @param {Schema} schema - Record's key-value schema
     * @param {string} keyPrefix - Record unique key's prefix.
     * `"users:1234"` --> "`keyPrefix`:`keyUnique`"
     * @param {ModelOptions} modelOption - Optional model settings. It's include 3 key.
     *   + `keyUnique`: it's unique part of model key
     *   + `flexSchema`: Normally, you can't define any key except the fields in `schema`,
     *                   but if this value is `true`, you can only add a value to the schema
     * by giving it `keyUnique`
     *   + `redisClientOptions`: node-redis client options.
     * @returns {Model} new record of Model
     */
    constructor(schema, keyPrefix = 'object', modelOption) {
        this.schema = schema;
        this.keyPrefix = keyPrefix;
        this.flexSchema = modelOption?.flexSchema ? modelOption?.flexSchema : false;
        new Logger_1.default(modelOption?.log);
        if (!this.flexSchema) {
            if (Object.keys(schema).length === 0) {
                (0, Utilities_1.throwError)('Only flex schema can be empty! Set the "modelOption.flexSchema" to "true"');
            }
            Object.entries(schema).forEach(([key, value]) => {
                if (!value.type) {
                    (0, Utilities_1.throwError)(`"${key}" key must have to "type" property in the schema!`);
                }
                if (typeof value.type !== 'function') {
                    (0, Utilities_1.throwError)(`"schema.${key}.type" must be constructor! You send "${value.type}"`);
                }
            });
        }
        if (!modelOption?.keyUnique) {
            this.keyUnique = undefined;
        }
        else {
            if (!Object.keys(schema).includes(modelOption?.keyUnique)) {
                (0, Utilities_1.throwError)(`${modelOption?.keyUnique} keyUnique must be in to schema!`);
            }
            this.keyUnique = modelOption?.keyUnique;
        }
        this.redisClient = new NodeRedisAdaptor_1.default(modelOption?.redisClientOptions);
        try {
            this.redisClient.connect();
        }
        catch (error) {
            (0, Utilities_1.throwError)(`Metronom: redis connecting error: ${error.message}`);
        }
    }
    // #region WRITE OPERATIONS
    /**
     * Creates `ModelInstance` by parameter then saves it to Redis and returns it
     * @param {Object} valueObject - data to be saved according to the `Model.schema`
     * @returns {ModelInstance} new ModelInstance
     */
    async create(valueObject) {
        if (!(0, Utilities_1.isObject)(valueObject) && !Array.isArray(valueObject)) {
            (0, Utilities_1.throwError)(`Value must be object or array!. Your type is: ${typeof valueObject}`);
        }
        const redisKey = this.generateRedisKey(valueObject);
        const isExist = (await this.redisClient.keys(redisKey)).length > 0;
        if (isExist) {
            (0, Utilities_1.throwError)(`"${redisKey}" already exist!`);
        }
        valueObject = await this._write(redisKey, valueObject);
        return this.createInstance(valueObject, { redisKey });
    }
    /**
   * Internal record save function
   * @param redisKey - Redis record key with/without `keyUnique`
   * @param data
   * @returns raw data
   */
    async _write(redisKey, data) {
        if (!redisKey.toString().startsWith(`${this.keyPrefix}:`)) {
            redisKey = `${this.keyPrefix}:${redisKey}`;
        }
        return await (0, Utilities_1.safeWrite)(data, redisKey, this.redisClient, this.schema, this.flexSchema);
    }
    // #endregion WRITE OPERATIONS
    // #region READ OPERATIONS
    /**
     * Internal read function
     * @param redisKey - Redis record key with/without `keyUnique`
     * @returns raw data
     */
    async _read(redisKey) {
        if (!redisKey.toString().startsWith(`${this.keyPrefix}:`)) {
            redisKey = `${this.keyPrefix}:${redisKey}`;
        }
        return await (0, Utilities_1.safeRead)(redisKey, this.redisClient, this.schema);
    }
    /**
     * Fetches record by `keyUnique`
     * @param {number | string} id - `keyUnique`
     * @returns {ModelInstance} ModelInstance or null
     */
    async findById(id) {
        const redisKey = `${this.keyPrefix}:${id}`;
        const response = await this._read(redisKey);
        if (Object.entries(response).length === 0) {
            return null;
        }
        return this.createInstance(response, { redisKey });
    }
    /**
     * Fetches all records with the same `keyPrefix` value
     * @returns {Array<ModelInstance>} List of ModelInstance
     */
    async getAll(options) {
        let keys = await this.redisClient.keys(`${this.keyPrefix}:*`);
        if (options?.limit) {
            keys = keys.slice(0, options.limit);
        }
        const results = [];
        // eslint-disable-next-line no-restricted-syntax
        for await (const key of keys) {
            const response = await this._read(key);
            results.push(this.createInstance(response, { redisKey: key }));
        }
        return results;
    }
    /**
     * Filters in the same way as `Array.filter`, pulling all records with the same `keyPrefix` value
     * @param filterFunction - It takes the values `(value, index, array)` and returns `true`
     * then the record is filtered. It can be asynchronous function
     * @returns Filtred ModelInstances or empty array
     */
    async filter(filterFunction) {
        if (typeof filterFunction !== 'function') {
            (0, Utilities_1.throwError)('The type of the parameter of the "filter" function must be "function"!');
        }
        const records = await this.getAll();
        const filtredRecords = records.filter(async (value, index, array) => await filterFunction(value, index, array));
        return filtredRecords;
    }
    // #endregion READ OPERATIONS
    // #region DELETE OPERATIONS
    /**
     * delete record by `keyUnique`
     * @param {number | string} id - `keyUnique`
     * @returns {number} deleted records count it always '1' if it succesfull
     */
    async deleteById(id) {
        return await this.redisClient.del(`${this.keyPrefix}:${id}`);
    }
    /**
     * Delete all records with the same `keyPrefix` value
     * @returns {number} deleted records count or 0
     */
    async deleteAll(options) {
        const keys = await this.redisClient.keys(`${this.keyPrefix}:*`);
        return keys.length > 0 ? await this.redisClient.del(keys) : 0;
    }
    // #endregion DELETE OPERATIONS
    /**
     * Redis command executer
     * @param {Array<any>} commands - Redis command list.
     * @example
     * ```
     * runCommand(['hget', 'user:1234', 'name'])
     * ```
     */
    async runCommand(commands) {
        return await this.redisClient.sendCommand(commands);
    }
    /**
     * Generate full redis key. if model has a `keyUnique` use it
     * from `data` else generate random unique
     * @param data - ModelInstance data
     */
    generateRedisKey(data) {
        const unique = this.keyUnique
            ? (0, Utilities_1.getKeyValue)(this.keyUnique.toString())(data)
            : Date.now() + Math.floor(Math.random() * 99999);
        return `${this.keyPrefix}:${unique}`;
    }
    /**
     * Create ModelInstance from raw data
     * @param data - raw
     * @param dataInfo
     */
    createInstance(data, dataInfo) {
        return new ModelInstance_1.default(data, this, dataInfo);
    }
}
exports.default = Model;

import IRedisAdaptor from './IRedisAdaptor';
import ModelInstance from './ModelInstance';
import { Schema, ModelOptions, FilterOptions, FilterFunction } from './Interfaces';
/**
 * Model Class
 * @class Model
 * @category Model
 */
declare class Model {
    [index: string]: any;
    /** First part of redis key. It's identifier for model class */
    keyPrefix: String;
    /** Second part of redis key. It's identifier for record */
    keyUnique: String | undefined;
    /** Object struct model */
    schema: Schema;
    redisClient: IRedisAdaptor;
    /** you can't define any key except the fields in `schema`, but if this value is `true`,
     * you can only add a value to the schema by giving it `keyUnique`
     */
    flexSchema: Boolean | undefined;
    /**
     * Represents a Metronom ORM Model
     * @constructor
     * @param {Schema} schema - Record's key-value schema
     * @param {string} keyPrefix - Record unique key's prefix.
     * `"users:1234"` --> "`keyPrefix`:`keyUnique`"
     * @param {ModelOptions} modelOption - Optional model settings. It's include 3 key.
     *   + `keyUnique`: it's unique part of model key
     *   + `flexSchema`: Normally, you can't define any key except the fields in `schema`,
     *                   but if this value is `true`, you can only add a value to the schema
     * by giving it `keyUnique`
     *   + `redisClientOptions`: node-redis client options.
     * @returns {Model} new record of Model
     */
    constructor(schema: Schema, keyPrefix?: string, modelOption?: ModelOptions);
    /**
     * Creates `ModelInstance` by parameter then saves it to Redis and returns it
     * @param {Object} valueObject - data to be saved according to the `Model.schema`
     * @returns {ModelInstance} new ModelInstance
     */
    create(valueObject: Object): Promise<ModelInstance>;
    /**
   * Internal record save function
   * @param redisKey - Redis record key with/without `keyUnique`
   * @param data
   * @returns raw data
   */
    private _write;
    /**
     * Internal read function
     * @param redisKey - Redis record key with/without `keyUnique`
     * @returns raw data
     */
    private _read;
    /**
     * Fetches record by `keyUnique`
     * @param {number | string} id - `keyUnique`
     * @returns {ModelInstance} ModelInstance or null
     */
    findById(id: any): Promise<ModelInstance | null>;
    /**
     * Fetches all records with the same `keyPrefix` value
     * @returns {Array<ModelInstance>} List of ModelInstance
     */
    getAll(options?: FilterOptions): Promise<Array<ModelInstance> | []>;
    /**
     * Filters in the same way as `Array.filter`, pulling all records with the same `keyPrefix` value
     * @param filterFunction - It takes the values `(value, index, array)` and returns `true`
     * then the record is filtered. It can be asynchronous function
     * @returns Filtred ModelInstances or empty array
     */
    filter(filterFunction: FilterFunction): Promise<Array<ModelInstance> | []>;
    /**
     * delete record by `keyUnique`
     * @param {number | string} id - `keyUnique`
     * @returns {number} deleted records count it always '1' if it succesfull
     */
    deleteById(id: any): Promise<number>;
    /**
     * Delete all records with the same `keyPrefix` value
     * @returns {number} deleted records count or 0
     */
    deleteAll(options?: any): Promise<number>;
    /**
     * Redis command executer
     * @param {Array<any>} commands - Redis command list.
     * @example
     * ```
     * runCommand(['hget', 'user:1234', 'name'])
     * ```
     */
    runCommand(commands: any | Array<String>): Promise<any>;
    /**
     * Generate full redis key. if model has a `keyUnique` use it
     * from `data` else generate random unique
     * @param data - ModelInstance data
     */
    private generateRedisKey;
    /**
     * Create ModelInstance from raw data
     * @param data - raw
     * @param dataInfo
     */
    private createInstance;
}
export default Model;
